/*
 *
 * Copyright 2013-2014 by MotionPortrait, Inc.
 *
 * All rights reserved.
 *
 */

#ifndef MPFACE_H_
#define MPFACE_H_

#include "mptypes.h"

#ifdef WEBGL
#include <string>
#endif

namespace motionportrait {


class MpFaceImpl;
class MpCtlSpeech;
class MpCtlAnimation;
class MpCtlItem;
class faceBinBase;

/**
 * \class MpFace
 *
 * MpFace class controls load/unload an avatar instance.
 */
class MpFace {

  public:

    /**
     * load face.
     *
     * note:
     * item/animation/speech on previous face are automatically reset.
     * this function must be called from GL thread
     *
     * @param pathFace : path to face file
     */
    mpResult Load(const char *pathFace);
    
    /**
     * load face.
     *
     * note:
     * item/animation/speech on previous face are automatically reset.
     * this function must be called from GL thread.
     *
     * @param faceObject face object generated by MySynth::Synth()
     */
    mpResult Load(mpFaceObject faceObject);
    
    /**
     * unload face.
     * this function must be called from the same GL thread
     * where Load was called.
     *
     */
    mpResult Unload();
    
    /**
     * load decolation item.
     *
     * @param pathItem : path to decolation item file
     */
    mpResult LoadDecoItem(const char *pathItem);

    /**
     * get animation controller
     *
     * @return MpAnimation handler
     */
    MpCtlAnimation* GetCtlAnimation();

    /**
     * get speech controller
     *
     * @return MpSpeech handler
     */
    MpCtlSpeech* GetCtlSpeech();

    /**
     * item type
     */
    typedef enum {
        ITEM_TYPE_HAIR,         /**< wig          */
        ITEM_TYPE_BEARD,        /**< facial hair  */
        ITEM_TYPE_GLASSES,      /**< glasses      */
        ITEM_TYPE_ACCESSORY,    /**< accessory    */
        ITEM_TYPE_CONTACT_LENS, /**< contact lens */
    } ItemType;

    /**
     * get item controller
     *
     * @param itemType : item type
     * @return MpItem handler
     */
    MpCtlItem* GetCtlItem(MpFace::ItemType itemType);

    class FaceImage {
      public:
        FaceImage();
        ~FaceImage();

        int w_;
        int h_;
        unsigned char *rgb_;

      private:
        // No copy. to prevent rgb_ from double free
        FaceImage& operator=(FaceImage &val)
        {
            (void)val;
            return *this;
        }
    };

    /**
     * get image data of face.
     * mainly for thumbnail
     *
     * @param pathFace  : path to face file
     * @param thumbnail : image data of face
     */
    static mpResult GetThumbnail(const char *pathFace, FaceImage &thumbnail);

    /**
     * get image data of face.
     * mainly for thumbnail
     *
     * @param faceObject : face object generated by MySynth::Synth()
     * @param thumbnail  : image data of face
     */
    static mpResult GetThumbnail(mpFaceObject faceObject, FaceImage &thumbnail);

    typedef struct {
        mpVector2 eyeLeft;      /**< left eye */
        mpVector2 eyeRight;     /**< right eye */
        mpVector2 mouth;        /**< center of mouth */
    } PartsPosition;

    /**
     * get face parts position: eyes, mouth
     *
     * @param pathFace  : path to face file
     * @param position  : position of face parts
     */
    static mpResult GetPartsPosition(const char *pathFace, PartsPosition &position);

    /**
     * get face parts position: eyes, mouth
     *
     * @param faceObject : face object generated by MySynth::Synth()
     * @param position  : position of face parts
     */
    static mpResult GetPartsPosition(mpFaceObject faceObject, PartsPosition &position);

    /**
     * texture id for ReplaceTexture()
     */
#ifdef WEBGL
    typedef int TextureId;
#else
    typedef enum {
        TEXTURE_LOWER_TEETH = 3,
        TEXTURE_UPPER_TEETH,
    } TextureId;
#endif

    /**
     * replace texture image
     *
     * @param id   : texture id
     * @param w    : width
     * @param h    : height
     * @param rgba : RGBA data. lower left origin coordinate
     */
    mpResult ReplaceTexture(TextureId id, int w, int h, unsigned char *rgba, bool flipTextureFlag = false);

    /**
     * enable to adjust pupil position.
     * this API is for accurate contact lens fitting
     *
     * @param en : if true, adjust pupil position at MpFace::Load()
     */
    mpResult EnableAdjustPupilPosition(bool en);

    typedef enum {
        EXPOSURE_TARGET_FACE,
        EXPOSURE_TARGET_TEETH,
    } ExposureTarget;

    /**
     * use auto exposure
     *
     * @param target : part of face
     * @param enable true: enable, false: disable
     */
    mpResult UseAutoExposure(MpFace::ExposureTarget target, bool enable);

    /**
     * set white balance
     *
     * @param r : red
     * @param g : green
     * @param b : blue
     */
    mpResult SetWhiteBalance(float r, float g, float b);

    /**
     * load face, except for texture.
     *
     * note:
     *  For WebGL performance, OpenGL texture will be generated by WebGL
     *  and set by LoadTexture();
     *
     * @param pathFace : path to face file
     */
    mpResult LoadMpbOnly(const char *pathFace);

    /**
     * load OpenGL texture id, generated by WebGL
     *
     * @param id   : texture id
     * @param glid : OpenGL texture id
     */
    mpResult LoadTexture(TextureId id, int glid);

#ifdef WEBGL
    mpResult Load(std::string pathFace) {
        return this->Load(pathFace.c_str());
    }
    mpResult ReplaceTexture(TextureId id, int w, int h, intptr_t rgba, bool flipTextureFlag) {
        return ReplaceTexture(id, w, h, reinterpret_cast<unsigned char *>(rgba), flipTextureFlag);
    }
    mpResult LoadMpbOnly(std::string pathFace) {
        return this->LoadMpbOnly(pathFace.c_str());
    }
#endif
    
    int GetEyeContour(bool left, mpVector2** posArray, int* posNum);

    /**
     */
    MpFace();
    virtual ~MpFace();

    /** */
    MpFaceImpl *mp_;
};


} // namespace motionportrait

#endif /* MPFACE_H_ */
